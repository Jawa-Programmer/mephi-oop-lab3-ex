Дополнительное задание к третьей лабораторной работе
=====
Суть задачи в том, чтобы организовать параллельную работу сервиса компоновки шаблонов документов.

Имеется шаблоны документов, которые представляют собой строки с местоуказателями формата `#{name}`.
Шаблоны хранятся во каком-то внутреннем хранилище сервиса (например, в поле
`Map<String, IDocumentTemplate>`).  
Сервис имеет метод компоновки шаблона - для каждого местоуказателя производится попытка подставить
другой шаблон из репозитория.
Пример:

```
templateA = A #{templateB} B #{templateC}
templateB = C #{templateC}
templateC = D #{d}

После компоновки шаблона templateA будет получен шаблон
"A C D #{d} B D #{d}"
("#{templateB}" заменяется на "C #{templateC}", "#{templateC}" заменяется на "D #{d}")
```

В данном проекте уже реализованы сами классы документов, а так же присутствует интерфейс сервиса и
готовая реализация, в которой все операции ставят блокировку на всё время работы (
класс [BlockingDocumentService.java](src/main/java/ru/mephi/dozen/oop/lab3/service/impl/BlockingDocumentService.java)).
Эта реализация крайне неэффективна.  
**Задача: написать более эффективную реализацию сервиса, методы которого могут вызываться из разных потоков, а также распараллелить процесс компоновки шаблона ForkJoin подходом.** Реализацию поместить в файл [ParallelDocumentService](src/main/java/ru/mephi/dozen/oop/lab3/service/impl/ParallelDocumentService.java)

Проверить, что реализация выполняет то, что от нее требуется, можно с помощью JUnit
тестов [ParallelDocumentServiceTest](src/test/java/ru/mephi/dozen/oop/lab3/service/ParallelDocumentServiceTest.java).
Тест multithreadingTest отмечен как @Disabled, так как выполняется
долго, но его можно запустить вручную. Он замеряет среднее время работы методов сервиса и проверяет
способность сервиса работать в
многопоточной среде.