Дополнительное задание к третьей лабораторной работе
=====
Суть задачи в том, чтобы организовать параллельную работу сервиса компоновки шаблонов документов.

Имеется шаблоны документов, которые представляют собой строки с местоуказателями формата `#{name}`.
Шаблоны хранятся во каком-то внутреннем хранилище сервиса (например, в поле
`Map<String, IDocumentTemplate>`).  
Сервис имеет метод компоновки шаблона - для каждого местоуказателя производится попытка подставить
цифровую подпись
другого шаблона из репозитория.
Пример:

```
templateA = A #{templateB} B #{templateC}
templateB = C #{templateC}
templateC = D #{d}

После компоновки шаблона templateA будет получен шаблон
"A <цифровая подпись templateB> B <цифровая подпись templateC>"
(при этом для формирования подписи шаблона templateB в него будет предварительно вставлена подпись шаблона templateC)
```

В данном проекте уже реализованы сами классы документов, а так же присутствует интерфейс сервиса и
готовая реализация, в которой все операции ставят блокировку на всё время работы (
класс [BlockingDocumentService.java](src/main/java/ru/mephi/dozen/oop/lab3/service/impl/BlockingDocumentService.java)).
Эта реализация крайне неэффективна.  
**Задача: написать более эффективную реализацию сервиса, методы которого могут вызываться из разных потоков, а также распараллелить процесс компоновки шаблона ForkJoin подходом.** Реализацию поместить в файл [ParallelDocumentService](src/main/java/ru/mephi/dozen/oop/lab3/service/impl/ParallelDocumentService.java)

Проверить, что реализация выполняет то, что от нее требуется, можно с помощью JUnit
тестов [ParallelDocumentServiceTest](src/test/java/ru/mephi/dozen/oop/lab3/service/ParallelDocumentServiceTest.java).
Тест benchmark для блокирующей реализации может работать несколько минут, это нормально. Зато для
многопоточной реализации он уже должен работать за десятки секунд, что тоже может говорить о том, в
правильном ли направлении идёт решение задачи